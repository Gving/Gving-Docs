/// <reference path="Iterator.ts"/>
/// <reference path="ArrayList.ts"/>
var io;
(function (io) {
    (function (retype) {
        (function (lang) {
            /**
            *
            */
            var Collection = (function () {
                function Collection() {
                }
                /**
                * <p>Get an iterator over the collection, that will iterate over each element.</p>
                * @abstract
                */
                Collection.prototype.iterator = function () {
                    throw new Error("Abstract method");
                };

                /**
                * Add the given element into the collection.
                * @param {T} item Element to be added.
                * @abstract
                */
                Collection.prototype.add = function (item) {
                    throw new Error("Abstract method");
                };

                /**
                * <p>Adds all the elements from the collection given as a parameter into
                * this collection.</p>
                * @param {Collection<T>} items
                */
                Collection.prototype.addAll = function (items) {
                    var _this = this;
                    items.forEach(function (x) {
                        return _this.add(x);
                    });
                };

                /**
                * <p>Removes the element from the collection.</p>
                * @param item
                */
                Collection.prototype.remove = function (item) {
                    throw new Error("Abstract method");
                };

                /**
                * <p>Returns the number of stored items in the collection.</p>
                */
                Collection.prototype.size = function () {
                    throw new Error("Abstract method");
                };

                /**
                * <p>Returns true if the collection has no elements.</p>
                */
                Collection.prototype.isEmpty = function () {
                    throw new Error("Abstract method");
                };

                /**
                * <p>Iterates over each element executing the given function with the element
                * given as a parameter.</p>
                * @param f
                * @param thisParam
                * @returns {io.retype.lang.Collection}
                */
                Collection.prototype.forEach = function (f, thisParam) {
                    var it = this.iterator(), index = 0;

                    while (it.hasNext()) {
                        f.call(thisParam, it.next(), index++, this);
                    }

                    return this;
                };

                /**
                * <p>Creates a new collection from the giving collection, by transforming
                * each element via the function giving as argument.<p>
                * @param f
                * @param thisParam
                * @returns {io.retype.lang.ArrayList<T>}
                */
                Collection.prototype.map = function (f, thisParam) {
                    var result = new io.retype.lang.ArrayList();
                    this.forEach(function (it, index, arr) {
                        return result.add(f(it, index, arr));
                    }, thisParam);

                    return result;
                };

                /**
                * <p>Reduces the current collection to an item that is returned by processing
                * the elements in the collection using the given function.</p>
                * <p>If the initialValue is passed then reduce will iterate over each element.</p>
                * <p>If the initialValue is not passed, then the first element of the collection
                * will be the initial value of the accumulator, and the callback function will be
                * called for each element, starting with the second element.</p>
                * @param f
                * @param initialValue
                * @returns {*}
                */
                Collection.prototype.reduce = function (f, initialValue) {
                    var result, firstReached = false;

                    if (typeof (initialValue) !== "undefined") {
                        result = initialValue;
                        firstReached = true;
                    }

                    this.forEach(function (it, index, collection) {
                        if (firstReached) {
                            result = f(result, it, index, collection);
                        } else {
                            result = it;
                            firstReached = true;
                        }
                    });

                    return result;
                };

                /**
                * <p>Filter all the items in the collection, keeping only the ones where the
                * condition check via the function given passes.</p>
                * @param f
                * @returns {io.retype.lang.Collection<T>}
                */
                Collection.prototype.filter = function (f, thisParam) {
                    var result = new io.retype.lang.ArrayList();

                    this.forEach(function (it, index, collection) {
                        if (f.call(thisParam, it, index, collection)) {
                            result.add(it);
                        }
                    }, thisParam);

                    return result;
                };

                /**
                * Join multiple elements, eventually interceding the symbol.
                * @param symbol
                * @returns {T}
                */
                Collection.prototype.join = function (symbol) {
                    var result = "";
                    symbol = typeof symbol !== "undefined" ? symbol : ",";

                    this.forEach(function (it, index) {
                        if (index == 0) {
                            result = "" + it;
                        } else {
                            if (symbol) {
                                result = result + symbol + it;
                            } else {
                                result = result + it;
                            }
                        }
                    });

                    return result;
                };

                /**
                * <p>Finds if there is at least one element in the collection where f(it) is true.</p>
                * @param f
                * @param thisParam
                * @returns {boolean}
                */
                Collection.prototype.some = function (f, thisParam) {
                    var iterator = this.iterator(), index = 0;

                    while (iterator.hasNext()) {
                        if (f.call(thisParam, iterator.next(), index++, this)) {
                            return true;
                        }
                    }

                    return false;
                };
                return Collection;
            })();
            lang.Collection = Collection;
        })(retype.lang || (retype.lang = {}));
        var lang = retype.lang;
    })(io.retype || (io.retype = {}));
    var retype = io.retype;
})(io || (io = {}));
/// <reference path="Collection.ts"/>
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var io;
(function (io) {
    (function (retype) {
        (function (lang) {
            /**
            * @abstract
            */
            var List = (function (_super) {
                __extends(List, _super);
                function List() {
                    _super.apply(this, arguments);
                }
                List.prototype.get = function (i) {
                    throw new Error("Abstract method");
                };
                return List;
            })(io.retype.lang.Collection);
            lang.List = List;
        })(retype.lang || (retype.lang = {}));
        var lang = retype.lang;
    })(io.retype || (io.retype = {}));
    var retype = io.retype;
})(io || (io = {}));
/// <reference path="List.ts"/>
var io;
(function (io) {
    (function (retype) {
        (function (lang) {
            /**
            * An iterator specific to an array list.
            */
            var ArrayListIterator = (function () {
                function ArrayListIterator(list) {
                    this.index = 0;
                    this.list = list;
                }
                ArrayListIterator.prototype.hasNext = function () {
                    return this.index < this.list.storage.length;
                };

                ArrayListIterator.prototype.next = function () {
                    return this.list.storage[this.index++];
                };
                return ArrayListIterator;
            })();

            /**
            * ArrayList is a very effective implementation of a list that allows fast
            * indexed access to its internal storage.
            */
            var ArrayList = (function (_super) {
                __extends(ArrayList, _super);
                function ArrayList(items) {
                    _super.call(this);
                    this.storage = [];

                    if (items) {
                        this.addAll(items);
                    }
                }
                ArrayList.prototype.iterator = function () {
                    return new ArrayListIterator(this);
                };

                ArrayList.prototype.add = function (o) {
                    this.storage.push(o);
                };

                ArrayList.prototype.remove = function (o) {
                    throw new Error("Abstract method");
                };

                ArrayList.prototype.size = function () {
                    return this.storage.length;
                };

                ArrayList.prototype.isEmpty = function () {
                    return this.storage.length == 0;
                };

                ArrayList.prototype.get = function (i) {
                    return this.storage[i];
                };
                return ArrayList;
            })(io.retype.lang.List);
            lang.ArrayList = ArrayList;
        })(retype.lang || (retype.lang = {}));
        var lang = retype.lang;
    })(io.retype || (io.retype = {}));
    var retype = io.retype;
})(io || (io = {}));
/// <reference path="ArrayList.ts"/>
var io;
(function (io) {
    (function (retype) {
        (function (lang) {
            /**
            * <p>Utilities for "reflection" in JavaScript, for example returning the function name
            * from a function object.</p>
            */
            var Reflect = (function () {
                function Reflect() {
                }
                /**
                * Return the function name from a function object.
                * @param f
                * @returns {*}
                */
                Reflect.functionName = function (f) {
                    return /^function\s*(.*?)\(/.exec(f.toString())[1];
                };

                /**
                * Return all the functions that are present into the given object.
                * @param obj
                * @returns {io.retype.lang.ArrayList<io.retype.lang.FunctionDefinition>}
                */
                Reflect.functionsList = function (obj) {
                    var key, result = new io.retype.lang.ArrayList();

                    for (key in obj) {
                        if (typeof (obj[key]) === "function") {
                            result.add({
                                name: key,
                                code: obj[key]
                            });
                        }
                    }

                    return result;
                };

                Reflect.argumentNames = function (f) {
                    return [];
                };
                return Reflect;
            })();
            lang.Reflect = Reflect;
        })(retype.lang || (retype.lang = {}));
        var lang = retype.lang;
    })(io.retype || (io.retype = {}));
    var retype = io.retype;
})(io || (io = {}));
var io;
(function (io) {
    (function (retype) {
        (function (log) {
            /**
            * The LogLevel marks what info should be displayed.
            */
            (function (LogLevel) {
                LogLevel[LogLevel["LOG"] = 0] = "LOG";
                LogLevel[LogLevel["INFO"] = 1] = "INFO";
                LogLevel[LogLevel["WARN"] = 2] = "WARN";
                LogLevel[LogLevel["ERROR"] = 3] = "ERROR";
            })(log.LogLevel || (log.LogLevel = {}));
            var LogLevel = log.LogLevel;
        })(retype.log || (retype.log = {}));
        var log = retype.log;
    })(io.retype || (io.retype = {}));
    var retype = io.retype;
})(io || (io = {}));
/// <reference path="LogLevel.ts"/>
var LogLevel = io.retype.log.LogLevel;

var io;
(function (io) {
    (function (retype) {
        (function (log) {
            

            /**
            * A log sink that writes to the console.log.
            */
            var ConsoleLogSink = (function () {
                function ConsoleLogSink() {
                }
                ConsoleLogSink.prototype.write = function (level, message) {
                    switch (level) {
                        case 0 /* LOG */:
                            console.log(message);
                            break;
                        case 1 /* INFO */:
                            console.info(message);
                            break;
                        case 2 /* WARN */:
                            console.warn(message);
                            break;
                        case 3 /* ERROR */:
                            console.error(message);
                            break;
                    }
                };
                return ConsoleLogSink;
            })();
            log.ConsoleLogSink = ConsoleLogSink;
        })(retype.log || (retype.log = {}));
        var log = retype.log;
    })(io.retype || (io.retype = {}));
    var retype = io.retype;
})(io || (io = {}));
var io;
(function (io) {
    (function (retype) {
        (function (lang) {
            /**
            * <p>Utilities functions for string manipulations.</p>
            */
            (function (stringutils) {
                /**
                * A function that formats a String, using {0}, {1}, etc as arguments for formatting.
                * @param format
                * @param args
                * @returns {string}
                */
                function format(format) {
                    var args = [];
                    for (var _i = 0; _i < (arguments.length - 1); _i++) {
                        args[_i] = arguments[_i + 1];
                    }
                    // we're not doing regexp for performance reasons.
                    var result = "", parameterIndex, foundToken = false, lastTokenFound = 0, j;

                    for (var i = 0; i < format.length; i++) {
                        if (format[i] == "{") {
                            foundToken = false;

                            j = i + 1;

                            while (format[j] != '}' && format[j] >= '0' && format[j] <= '9' && j < format.length) {
                                j++;
                            }

                            if (j < format.length && format[j] == '}' && j - i > 1) {
                                foundToken = true;
                            } else {
                                i = j - 1; // no tokens until here.
                                continue;
                            }

                            // since i and j land on brackets, make sure we cut the parameter right.
                            parameterIndex = parseInt(format.substring(i + 1, j));

                            if (parameterIndex < args.length) {
                                result += format.substring(lastTokenFound, i) + args[parameterIndex];
                            }

                            lastTokenFound = j + 1;
                        }
                    }

                    result += format.substring(lastTokenFound, format.length);

                    return result;
                }
                stringutils.format = format;
            })(lang.stringutils || (lang.stringutils = {}));
            var stringutils = lang.stringutils;
        })(retype.lang || (retype.lang = {}));
        var lang = retype.lang;
    })(io.retype || (io.retype = {}));
    var retype = io.retype;
})(io || (io = {}));
/// <reference path="../lang/Reflect.ts"/>
/// <reference path="../lang/StringUtils.ts"/>
/// <reference path="LogLevel.ts"/>
var io;
(function (io) {
    (function (retype) {
        (function (log) {
            var format = io.retype.lang.stringutils.format;

            

            /**
            * Formats the message including the error the level and the class
            * it originated from.
            */
            var DefaultLoggerFormatter = (function () {
                function DefaultLoggerFormatter(clazz) {
                    this.className = null;
                    if (clazz) {
                        this.className = io.retype.lang.Reflect.functionName(clazz);
                    }
                }
                DefaultLoggerFormatter.prototype.formatMessage = function (level, message) {
                    var stringLevel;

                    switch (level) {
                        case 3 /* ERROR */:
                            stringLevel = "ERROR";
                            break;
                        case 0 /* LOG */:
                            stringLevel = "LOG  ";
                            break;
                        case 1 /* INFO */:
                            stringLevel = "INFO ";
                            break;
                        case 2 /* WARN */:
                            stringLevel = "WARN ";
                            break;

                        default:
                            stringLevel = "UNKNOWN";
                    }

                    return this.className ? format("[{0}] {1}: {2}", stringLevel, this.className, message) : format("[{0}] {1}", stringLevel, message);
                };
                return DefaultLoggerFormatter;
            })();
            log.DefaultLoggerFormatter = DefaultLoggerFormatter;
        })(retype.log || (retype.log = {}));
        var log = retype.log;
    })(io.retype || (io.retype = {}));
    var retype = io.retype;
})(io || (io = {}));
/// <reference path="../lang/Reflect.ts"/>
/// <reference path="LogSink.ts"/>
/// <reference path="LoggerFormatter.ts"/>
/// <reference path="LogLevel.ts"/>
var io;
(function (io) {
    (function (retype) {
        (function (log) {
            /**
            * <p>Logger are classes associated with classes that are able to output messages.</p>
            * <p>Logger classes do not do the writing to the output sources themselves, <code>LogSink</code>
            * instances do.</p>
            * <p>Logger classes also don't do any formatting, <code>LoggerFormatter</code> instances do.</p>
            */
            var Logger = (function () {
                function Logger(clazz) {
                    this.formatter = new io.retype.log.DefaultLoggerFormatter(clazz);
                    this.sink = new io.retype.log.ConsoleLogSink();
                }
                Logger.prototype.log = function (message) {
                    this.sink.write(0 /* LOG */, this.formatter.formatMessage(0 /* LOG */, message));
                };

                Logger.prototype.info = function (message) {
                    this.sink.write(1 /* INFO */, this.formatter.formatMessage(1 /* INFO */, message));
                };

                Logger.prototype.warn = function (message) {
                    this.sink.write(2 /* WARN */, this.formatter.formatMessage(2 /* WARN */, message));
                };

                Logger.prototype.error = function (message) {
                    this.sink.write(3 /* ERROR */, this.formatter.formatMessage(3 /* ERROR */, message));
                };
                return Logger;
            })();
            log.Logger = Logger;
        })(retype.log || (retype.log = {}));
        var log = retype.log;
    })(io.retype || (io.retype = {}));
    var retype = io.retype;
})(io || (io = {}));
/// <reference path="../log/Logger.ts"/>
var io;
(function (io) {
    (function (retype) {
        (function (feature) {
            var Logger = io.retype.log.Logger;
            var format = io.retype.lang.stringutils.format;

            /**
            * Browser feature detection holds its results here.
            */
            var Feature = (function () {
                function Feature() {
                }
                Feature.testFeature = function (name, actualTest) {
                    Feature._detected[name] = actualTest();

                    Feature.LOG.log(format("Feature '{0}' detected with value: '{1}'.", name, Feature._detected[name]));
                };

                Feature.getFeature = function (name) {
                    return Feature._detected[name];
                };
                Feature._detected = {};

                Feature.LOG = new Logger(Feature);
                return Feature;
            })();
            feature.Feature = Feature;
        })(retype.feature || (retype.feature = {}));
        var feature = retype.feature;
    })(io.retype || (io.retype = {}));
    var retype = io.retype;
})(io || (io = {}));
/// <reference path="Feature.ts"/>
/// <reference path="ArrayList.ts"/>
var io;
(function (io) {
    (function (retype) {
        (function (lang) {
            var Collections = (function () {
                function Collections() {
                }
                Collections.list = function (items) {
                    var result = new io.retype.lang.ArrayList();

                    for (var i = 0; i < items.length; i++) {
                        result.add(items[i]);
                    }

                    return result;
                };
                return Collections;
            })();
            lang.Collections = Collections;
        })(retype.lang || (retype.lang = {}));
        var lang = retype.lang;
    })(io.retype || (io.retype = {}));
    var retype = io.retype;
})(io || (io = {}));
var io;
(function (io) {
    (function (retype) {
        (function (lang) {
            /**
            * <p>A OnceMany will return the first element once when its next() method
            * will be called, and from that moment on always return the other value.</p>
            */
            var OnceMany = (function () {
                function OnceMany(first, allNext) {
                    this.first = first;
                    this.allNext = allNext;
                    this.firstPassed = false;
                }
                OnceMany.prototype.hasNext = function () {
                    return true;
                };

                OnceMany.prototype.next = function () {
                    if (this.firstPassed) {
                        return this.allNext;
                    }

                    this.firstPassed = true;

                    return this.first;
                };
                return OnceMany;
            })();
            lang.OnceMany = OnceMany;
        })(retype.lang || (retype.lang = {}));
        var lang = retype.lang;
    })(io.retype || (io.retype = {}));
    var retype = io.retype;
})(io || (io = {}));
/// <reference path="ArrayList.ts"/>
/// <reference path="Reflect.ts"/>
/// <reference path="StringUtils.ts"/>
/// <reference path="Collections.ts"/>
/// <reference path="OnceMany.ts"/>
/// <reference path="Logger.ts"/>
var io;
(function (io) {
    (function (retype) {
        (function (template) {
            var TemplateRenderer = (function () {
                function TemplateRenderer() {
                }
                TemplateRenderer.prototype.renderContent = function (templateContent, templateParameters) {
                    throw new Error("Abstract method");
                };
                return TemplateRenderer;
            })();
            template.TemplateRenderer = TemplateRenderer;
        })(retype.template || (retype.template = {}));
        var template = retype.template;
    })(io.retype || (io.retype = {}));
    var retype = io.retype;
})(io || (io = {}));
/// <reference path="TemplateRenderer.ts"/>
var io;
(function (io) {
    (function (retype) {
        (function (template) {
            /**
            * <p>Access source to all the template renderers registered into the system.</p>
            * <p>Each template renderer must be registered with registerRenderer.</p>
            */
            var TemplateRendererFactory = (function () {
                function TemplateRendererFactory() {
                    this._registeredRenderers = {};
                }
                TemplateRendererFactory.getInstance = function () {
                    if (TemplateRendererFactory.INSTANCE == null) {
                        TemplateRendererFactory.INSTANCE = new TemplateRendererFactory();
                    }

                    return TemplateRendererFactory.INSTANCE;
                };

                /**
                * Return a renderer for a given name. Multiple renderers can be registered into the system.
                * @param name
                */
                TemplateRendererFactory.prototype.getRenderer = function (name) {
                    return this._registeredRenderers[name];
                };

                /**
                * <p>Register a renderer to be available for creating.</p>
                * @param name
                * @param renderer
                */
                TemplateRendererFactory.prototype.registerRenderer = function (name, renderer) {
                    this._registeredRenderers[name] = renderer;
                };
                return TemplateRendererFactory;
            })();
            template.TemplateRendererFactory = TemplateRendererFactory;
        })(retype.template || (retype.template = {}));
        var template = retype.template;
    })(io.retype || (io.retype = {}));
    var retype = io.retype;
})(io || (io = {}));
/// <reference path="TemplateRendererFactory.ts"/>
/// <reference path="../../feature/Feature.ts"/>
/// <reference path="../TemplateRenderer.ts"/>
/// <reference path="../TemplateRendererFactory.ts"/>
var io;
(function (io) {
    (function (retype) {
        (function (template) {
            (function (handlebars) {
                var Feature = io.retype.feature.Feature;

                var HandlebarsTemplateRenderer = (function (_super) {
                    __extends(HandlebarsTemplateRenderer, _super);
                    function HandlebarsTemplateRenderer() {
                        _super.apply(this, arguments);
                    }
                    HandlebarsTemplateRenderer.prototype.renderContent = function (templateContent, templateParameters) {
                        throw new Error("Abstract method.");
                    };
                    return HandlebarsTemplateRenderer;
                })(io.retype.template.TemplateRenderer);
                handlebars.HandlebarsTemplateRenderer = HandlebarsTemplateRenderer;

                Feature.testFeature("handlebars-renderer", function () {
                    if (typeof window === "undefined") {
                        return 'node';
                    } else {
                        return 'client';
                    }
                });
            })(template.handlebars || (template.handlebars = {}));
            var handlebars = template.handlebars;
        })(retype.template || (retype.template = {}));
        var template = retype.template;
    })(io.retype || (io.retype = {}));
    var retype = io.retype;
})(io || (io = {}));
/// <reference path="HandlebarsTemplateRenderer.ts"/>
/// <reference path="../../../feature/Feature.ts"/>
/// <reference path="../HandlebarsTemplateRenderer.ts"/>
/// <reference path="../../TemplateRendererFactory.ts"/>
/// <reference path="../../../platform/node/require.ts"/>
var io;
(function (io) {
    (function (retype) {
        (function (_template) {
            (function (handlebars) {
                (function (node) {
                    var Feature = io.retype.feature.Feature;
                    var TemplateRendererFactory = io.retype.template.TemplateRendererFactory;

                    var NodeHandlebarsTemplateRenderer = (function (_super) {
                        __extends(NodeHandlebarsTemplateRenderer, _super);
                        function NodeHandlebarsTemplateRenderer() {
                            _super.call(this);

                            if (NodeHandlebarsTemplateRenderer.NODE_HANDLEBARS == null) {
                                NodeHandlebarsTemplateRenderer.NODE_HANDLEBARS = require("handlebars");
                            }
                        }
                        NodeHandlebarsTemplateRenderer.prototype.renderContent = function (templateContent, templateParameters) {
                            var nodeHandlebars = NodeHandlebarsTemplateRenderer.NODE_HANDLEBARS;
                            var template = nodeHandlebars.compile(templateContent);

                            return template(templateParameters);
                        };
                        return NodeHandlebarsTemplateRenderer;
                    })(io.retype.template.handlebars.HandlebarsTemplateRenderer);
                    node.NodeHandlebarsTemplateRenderer = NodeHandlebarsTemplateRenderer;

                    if (Feature.getFeature("handlebars-renderer") === 'node') {
                        TemplateRendererFactory.getInstance().registerRenderer("handlebars", new NodeHandlebarsTemplateRenderer());
                    }
                })(handlebars.node || (handlebars.node = {}));
                var node = handlebars.node;
            })(_template.handlebars || (_template.handlebars = {}));
            var handlebars = _template.handlebars;
        })(retype.template || (retype.template = {}));
        var template = retype.template;
    })(io.retype || (io.retype = {}));
    var retype = io.retype;
})(io || (io = {}));
/// <reference path="NodeHandlebarsTemplateRenderer.ts"/>
/// <reference path="../lang/StringUtils.ts"/>
var io;
(function (io) {
    (function (retype) {
        (function (test) {
            (function (asserts) {
                var format = io.retype.lang.stringutils.format;

                function assertEquals(expected, actual, message) {
                    message = message ? message : format("Assertion failed. Expected `{0}` with type {1}, " + "got instead `{2}` with type {3}.", expected, typeof expected, actual, typeof actual);

                    if (expected !== actual) {
                        fail(message);
                    }
                }
                asserts.assertEquals = assertEquals;

                function assertTrue(expected, message) {
                    if (!expected) {
                        fail(message ? message : "Expected true, got instead false.");
                    }
                }
                asserts.assertTrue = assertTrue;

                function assertNotNull(actual, message) {
                    if ((typeof actual === "undefined") || (actual == null)) {
                        fail(message ? message : format("Expected a not null object, got instead {0} with type {1}.", actual, typeof actual));
                    }
                }
                asserts.assertNotNull = assertNotNull;

                function assertFalse(expected, message) {
                    if (expected) {
                        fail(message ? message : "Expected false, got instead true.");
                    }
                }
                asserts.assertFalse = assertFalse;

                function fail(message) {
                    if (message) {
                        throw new Error(message);
                    } else {
                        throw new Error();
                    }
                }
            })(test.asserts || (test.asserts = {}));
            var asserts = test.asserts;
        })(retype.test || (retype.test = {}));
        var test = retype.test;
    })(io.retype || (io.retype = {}));
    var retype = io.retype;
})(io || (io = {}));
var io;
(function (io) {
    (function (retype) {
        (function (test) {
            /**
            * <p>A class that is a Unit Test.</p>
            * <p>Unit tests have state, and can be initialized. All the methods that start with "test"
            * or end with "Test" will have their method called by a JsUnitTestRuner</p>
            * <p>If there are static methods named beforeClass, or afterClass, they will be called
            *
            * <p>This class also offers a lot of utility methods for doing the checks.</p>
            */
            var JsUnitTest = (function () {
                function JsUnitTest() {
                }
                return JsUnitTest;
            })();
            test.JsUnitTest = JsUnitTest;
        })(retype.test || (retype.test = {}));
        var test = retype.test;
    })(io.retype || (io.retype = {}));
    var retype = io.retype;
})(io || (io = {}));
/// <reference path="JsUnitTest.ts"/>
/// <reference path="../lang/Reflect.ts"/>
/// <reference path="../log/Logger.ts"/>
/// <reference path="Asserts.ts"/>
var io;
(function (io) {
    (function (retype) {
        (function (test) {
            var Logger = io.retype.log.Logger;

            /**
            * <p>A class that executes JsUnitTests.</p>
            * <p>This will call first the static method <i>beforeClass</i> if it exists, on the class, then
            * it will call all the methods that start with "test", or end with "Test", on the test instance,
            * then it will call the method <i>afterClass</i> if it exists.</p>
            */
            var JsUnitTestRunner = (function () {
                function JsUnitTestRunner() {
                }
                /**
                * Runs a single JUnit class.
                * @param clazz
                */
                JsUnitTestRunner.prototype.runClass = function (clazz) {
                    JsUnitTestRunner.LOG.log("running test: " + io.retype.lang.Reflect.functionName(clazz));

                    var testInstance = new clazz(), noTestFailed = true;

                    noTestFailed = this.executeBeforeClass(clazz);

                    // don't execute the tests if the initialisation failed
                    noTestFailed = noTestFailed && this.executeTests(testInstance);

                    // execute the cleanup even if the tests failed
                    noTestFailed = this.executeAfterClass(clazz) && noTestFailed;

                    if (noTestFailed) {
                        JsUnitTestRunner.LOG.log("Test passed.");
                    } else {
                        JsUnitTestRunner.LOG.error("Test FAILED.");
                    }
                };

                JsUnitTestRunner.prototype.executeBeforeClass = function (clazz) {
                    if (clazz.hasOwnProperty("beforeClass")) {
                        try  {
                            clazz['beforeClass']();
                        } catch (e) {
                            JsUnitTestRunner.LOG.error("Failure executing beforeClass");
                            return false;
                        }
                    }

                    return true;
                };

                JsUnitTestRunner.prototype.executeTests = function (testInstance) {
                    var key, noTestFailed = true;

                    io.retype.lang.Reflect.functionsList(testInstance).filter(function (f) {
                        return /^test/.test(f.name) || /Test$/.test(f.name);
                    }).forEach(function (f) {
                        try  {
                            f.code.call(testInstance, []);
                        } catch (e) {
                            JsUnitTestRunner.LOG.error("Test " + f.name + " failed: " + e.message);
                            noTestFailed = false;
                        }
                    });

                    return noTestFailed;
                };

                JsUnitTestRunner.prototype.executeAfterClass = function (clazz) {
                    if (clazz.hasOwnProperty("afterClass")) {
                        try  {
                            clazz['afterClass']();
                        } catch (e) {
                            JsUnitTestRunner.LOG.error("Failure executing afterClass");
                            return false;
                        }
                    }

                    return true;
                };
                JsUnitTestRunner.LOG = new Logger(JsUnitTestRunner);
                return JsUnitTestRunner;
            })();
            test.JsUnitTestRunner = JsUnitTestRunner;
        })(retype.test || (retype.test = {}));
        var test = retype.test;
    })(io.retype || (io.retype = {}));
    var retype = io.retype;
})(io || (io = {}));
/// <reference path="Asserts.ts"/>
/// <reference path="JsUnitTestRunner.ts"/>
/// <reference path="XmlParser.ts"/>
/// <reference path="../platform/node/require.ts"/>
var io;
(function (io) {
    (function (retype) {
        (function (xml) {
            var DOMParser = require("xmldom").DOMParser;

            /**
            * <p>Node XML parsing.</p>
            */
            var NodeXmlParser = (function () {
                function NodeXmlParser() {
                }
                NodeXmlParser.prototype.parse = function (data) {
                    var xmlDoc;

                    xmlDoc = new DOMParser().parseFromString(data, "text/xml");

                    return xmlDoc;
                };
                return NodeXmlParser;
            })();
            xml.NodeXmlParser = NodeXmlParser;
        })(retype.xml || (retype.xml = {}));
        var xml = retype.xml;
    })(io.retype || (io.retype = {}));
    var retype = io.retype;
})(io || (io = {}));
/// <reference path="XmlParser.ts"/>
var io;
(function (io) {
    (function (retype) {
        (function (xml) {
            /**
            * <p>A parser for XML for the IE browsers.</p>
            */
            var IeXmlParser = (function () {
                function IeXmlParser() {
                }
                IeXmlParser.prototype.parse = function (data) {
                    var xmlDoc;

                    xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
                    xmlDoc.async = false;
                    xmlDoc.loadXML(data);

                    return xmlDoc;
                };
                return IeXmlParser;
            })();
            xml.IeXmlParser = IeXmlParser;
        })(retype.xml || (retype.xml = {}));
        var xml = retype.xml;
    })(io.retype || (io.retype = {}));
    var retype = io.retype;
})(io || (io = {}));
/// <reference path="XmlParser.ts"/>
var io;
(function (io) {
    (function (retype) {
        (function (xml) {
            /**
            * <p>A normal W3C standard compliant browser parser.</p>
            */
            var BrowserXmlParser = (function () {
                function BrowserXmlParser() {
                }
                BrowserXmlParser.prototype.parse = function (data) {
                    var xmlDoc;

                    xmlDoc = new DOMParser().parseFromString(data, "text/xml");

                    return xmlDoc;
                };
                return BrowserXmlParser;
            })();
            xml.BrowserXmlParser = BrowserXmlParser;
        })(retype.xml || (retype.xml = {}));
        var xml = retype.xml;
    })(io.retype || (io.retype = {}));
    var retype = io.retype;
})(io || (io = {}));
/// <reference path="../feature/Feature.ts"/>
/// <reference path="XmlParser.ts"/>
/// <reference path="NodeXmlParser.ts"/>
/// <reference path="IeXmlParser.ts"/>
/// <reference path="BrowserXmlParser.ts"/>
var io;
(function (io) {
    (function (retype) {
        (function (xml) {
            var Feature = io.retype.feature.Feature;

            (function (ParserType) {
                ParserType[ParserType["DEFAULT"] = 0] = "DEFAULT";
                ParserType[ParserType["NODE"] = 1] = "NODE";
                ParserType[ParserType["IE"] = 2] = "IE";
            })(xml.ParserType || (xml.ParserType = {}));
            var ParserType = xml.ParserType;

            var XmlParserFactory = (function () {
                function XmlParserFactory() {
                }
                XmlParserFactory.createParserInstance = function () {
                    var parserType = Feature.getFeature("xmlParser");

                    switch (parserType) {
                        case 1 /* NODE */:
                            return new io.retype.xml.NodeXmlParser();
                        case 2 /* IE */:
                            return new io.retype.xml.IeXmlParser();
                        default:
                            return new io.retype.xml.BrowserXmlParser();
                    }
                };
                return XmlParserFactory;
            })();
            xml.XmlParserFactory = XmlParserFactory;

            Feature.testFeature("xmlParser", function () {
                if (typeof window === "undefined") {
                    return 1 /* NODE */;
                } else if (window['DOMParser']) {
                    return 0 /* DEFAULT */;
                } else {
                    return 2 /* IE */;
                }
            });
        })(retype.xml || (retype.xml = {}));
        var xml = retype.xml;
    })(io.retype || (io.retype = {}));
    var retype = io.retype;
})(io || (io = {}));
var io;
(function (io) {
    (function (retype) {
        (function (xml) {
            var XmlFormat = (function () {
                function XmlFormat() {
                }
                XmlFormat.prototype.format = function (xmlDocument) {
                    return null;
                };
                return XmlFormat;
            })();
            xml.XmlFormat = XmlFormat;
        })(retype.xml || (retype.xml = {}));
        var xml = retype.xml;
    })(io.retype || (io.retype = {}));
    var retype = io.retype;
})(io || (io = {}));
/// <reference path="XmlParserFactory.ts"/>
/// <reference path="XmlFormat.ts"/>
/// <reference path="feature/pack.ts"/>
/// <reference path="lang/pack.ts"/>
/// <reference path="log/pack.ts"/>
/// <reference path="template/pack.ts"/>
/// <reference path="template/handlebars/pack.ts"/>
/// <reference path="template/handlebars/node/pack.ts"/>
/// <reference path="test/pack.ts"/>
/// <reference path="xml/pack.ts"/>
exports.io = io;
