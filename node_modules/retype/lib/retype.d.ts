declare module io.retype.lang {
    interface Iterator<T> {
        hasNext(): boolean;
        next(): T;
    }
}
declare module io.retype.lang {
    /**
    *
    */
    class Collection<T> {
        /**
        * <p>Get an iterator over the collection, that will iterate over each element.</p>
        * @abstract
        */
        public iterator(): Iterator<T>;
        /**
        * Add the given element into the collection.
        * @param {T} item Element to be added.
        * @abstract
        */
        public add(item: T): void;
        /**
        * <p>Adds all the elements from the collection given as a parameter into
        * this collection.</p>
        * @param {Collection<T>} items
        */
        public addAll(items: Collection<T>): void;
        /**
        * <p>Removes the element from the collection.</p>
        * @param item
        */
        public remove(item: T): void;
        /**
        * <p>Returns the number of stored items in the collection.</p>
        */
        public size(): number;
        /**
        * <p>Returns true if the collection has no elements.</p>
        */
        public isEmpty(): boolean;
        /**
        * <p>Iterates over each element executing the given function with the element
        * given as a parameter.</p>
        * @param f
        * @param thisParam
        * @returns {io.retype.lang.Collection}
        */
        public forEach(f: (it: T, index: number, collection: Collection<T>) => void, thisParam?: any): Collection<T>;
        /**
        * <p>Creates a new collection from the giving collection, by transforming
        * each element via the function giving as argument.<p>
        * @param f
        * @param thisParam
        * @returns {io.retype.lang.ArrayList<T>}
        */
        public map(f: (it: T, index: number, collection: Collection<T>) => any, thisParam?: any): Collection<any>;
        /**
        * <p>Reduces the current collection to an item that is returned by processing
        * the elements in the collection using the given function.</p>
        * <p>If the initialValue is passed then reduce will iterate over each element.</p>
        * <p>If the initialValue is not passed, then the first element of the collection
        * will be the initial value of the accumulator, and the callback function will be
        * called for each element, starting with the second element.</p>
        * @param f
        * @param initialValue
        * @returns {*}
        */
        public reduce(f: (accumulator: any, item: T, index: number, collection: Collection<T>) => any, initialValue?: any): any;
        /**
        * <p>Filter all the items in the collection, keeping only the ones where the
        * condition check via the function given passes.</p>
        * @param f
        * @returns {io.retype.lang.Collection<T>}
        */
        public filter(f: (it: T, index: number, collection: Collection<T>) => boolean, thisParam?: any): Collection<T>;
        /**
        * Join multiple elements, eventually interceding the symbol.
        * @param symbol
        * @returns {T}
        */
        public join(symbol?: string): string;
        /**
        * <p>Finds if there is at least one element in the collection where f(it) is true.</p>
        * @param f
        * @param thisParam
        * @returns {boolean}
        */
        public some(f: (it: T, index: number, arr: Collection<T>) => boolean, thisParam?: any): boolean;
    }
}
declare module io.retype.lang {
    /**
    * @abstract
    */
    class List<T> extends Collection<T> {
        public get(i: number): T;
    }
}
declare module io.retype.lang {
    /**
    * ArrayList is a very effective implementation of a list that allows fast
    * indexed access to its internal storage.
    */
    class ArrayList<T> extends List<T> {
        public storage: any[];
        constructor(items?: Collection<T>);
        public iterator(): Iterator<T>;
        public add(o: T): void;
        public remove(o: T): void;
        public size(): number;
        public isEmpty(): boolean;
        public get(i: number): T;
    }
}
declare module io.retype.lang {
    interface FunctionDefinition {
        name: string;
        code: Function;
    }
    /**
    * <p>Utilities for "reflection" in JavaScript, for example returning the function name
    * from a function object.</p>
    */
    class Reflect {
        /**
        * Return the function name from a function object.
        * @param f
        * @returns {*}
        */
        static functionName(f: Function): string;
        /**
        * Return all the functions that are present into the given object.
        * @param obj
        * @returns {io.retype.lang.ArrayList<io.retype.lang.FunctionDefinition>}
        */
        static functionsList(obj: any): Collection<FunctionDefinition>;
        static argumentNames(f: Function): string[];
    }
}
declare module io.retype.log {
    /**
    * The LogLevel marks what info should be displayed.
    */
    enum LogLevel {
        LOG = 0,
        INFO = 1,
        WARN = 2,
        ERROR = 3,
    }
}
declare module io.retype.log {
    /**
    * This is a class where the messages will be written after they are formatted,
    * and if they match the level of debug format that was chosen.
    */
    interface LogSink {
        /**
        * <p>Logs the message into an actual output source. (the message is already formatted by a logger format).</p>
        * @param level
        * @param message
        */
        write(level: LogLevel, message: string): any;
    }
    /**
    * A log sink that writes to the console.log.
    */
    class ConsoleLogSink implements LogSink {
        public write(level: LogLevel, message: string): void;
    }
}
/**
* <p>Utilities functions for string manipulations.</p>
*/
declare module io.retype.lang.stringutils {
    /**
    * A function that formats a String, using {0}, {1}, etc as arguments for formatting.
    * @param format
    * @param args
    * @returns {string}
    */
    function format(format: string, ...args: any[]): string;
}
declare module io.retype.log {
    /**
    * Provides a default implementation for formatting the log names.
    */
    interface LoggerFormatter {
        formatMessage(level: LogLevel, message: string): string;
    }
    /**
    * Formats the message including the error the level and the class
    * it originated from.
    */
    class DefaultLoggerFormatter implements LoggerFormatter {
        private className;
        constructor(clazz?: Function);
        public formatMessage(level: LogLevel, message: string): string;
    }
}
declare module io.retype.log {
    /**
    * <p>Logger are classes associated with classes that are able to output messages.</p>
    * <p>Logger classes do not do the writing to the output sources themselves, <code>LogSink</code>
    * instances do.</p>
    * <p>Logger classes also don't do any formatting, <code>LoggerFormatter</code> instances do.</p>
    */
    class Logger {
        public sink: LogSink;
        public formatter: LoggerFormatter;
        constructor(clazz: Function);
        public log(message: string): void;
        public info(message: string): void;
        public warn(message: string): void;
        public error(message: string): void;
    }
}
declare module io.retype.feature {
    /**
    * Browser feature detection holds its results here.
    */
    class Feature {
        private static _detected;
        private static LOG;
        static testFeature(name: string, actualTest: Function): void;
        static getFeature(name: string): any;
    }
}
declare module io.retype.lang {
    class Collections {
        static list<T>(items: T[]): List<T>;
    }
}
declare module io.retype.lang {
    /**
    * <p>A OnceMany will return the first element once when its next() method
    * will be called, and from that moment on always return the other value.</p>
    */
    class OnceMany<T> implements Iterator<T> {
        public first: T;
        public allNext: T;
        private firstPassed;
        constructor(first: T, allNext: T);
        public hasNext(): boolean;
        public next(): T;
    }
}
declare module io.retype.template {
    class TemplateRenderer {
        public renderContent(templateContent: string, templateParameters?: any): string;
    }
}
declare module io.retype.template {
    /**
    * <p>Access source to all the template renderers registered into the system.</p>
    * <p>Each template renderer must be registered with registerRenderer.</p>
    */
    class TemplateRendererFactory {
        private static INSTANCE;
        private _registeredRenderers;
        static getInstance(): TemplateRendererFactory;
        /**
        * Return a renderer for a given name. Multiple renderers can be registered into the system.
        * @param name
        */
        public getRenderer(name: string): TemplateRenderer;
        /**
        * <p>Register a renderer to be available for creating.</p>
        * @param name
        * @param renderer
        */
        public registerRenderer(name: string, renderer: TemplateRenderer): void;
    }
}
declare module io.retype.template.handlebars {
    class HandlebarsTemplateRenderer extends TemplateRenderer {
        public renderContent(templateContent: string, templateParameters?: any): string;
    }
}
declare function require(name: string): any;
declare module io.retype.template.handlebars.node {
    class NodeHandlebarsTemplateRenderer extends HandlebarsTemplateRenderer {
        private static NODE_HANDLEBARS;
        constructor();
        public renderContent(templateContent: string, templateParameters?: any): string;
    }
}
declare module io.retype.test.asserts {
    function assertEquals(expected: Object, actual: Object, message?: string): void;
    function assertTrue(expected: boolean, message?: string): void;
    function assertNotNull(actual: Object, message?: string): void;
    function assertFalse(expected: boolean, message?: string): void;
}
declare module io.retype.test {
    /**
    * <p>A class that is a Unit Test.</p>
    * <p>Unit tests have state, and can be initialized. All the methods that start with "test"
    * or end with "Test" will have their method called by a JsUnitTestRuner</p>
    * <p>If there are static methods named beforeClass, or afterClass, they will be called
    *
    * <p>This class also offers a lot of utility methods for doing the checks.</p>
    */
    class JsUnitTest {
    }
}
declare module io.retype.test {
    /**
    * <p>A class that executes JsUnitTests.</p>
    * <p>This will call first the static method <i>beforeClass</i> if it exists, on the class, then
    * it will call all the methods that start with "test", or end with "Test", on the test instance,
    * then it will call the method <i>afterClass</i> if it exists.</p>
    */
    class JsUnitTestRunner {
        static LOG: log.Logger;
        /**
        * Runs a single JUnit class.
        * @param clazz
        */
        public runClass(clazz: any): void;
        private executeBeforeClass(clazz);
        private executeTests(testInstance);
        private executeAfterClass(clazz);
    }
}
declare module io.retype.xml {
    /**
    * <p>A XmlParser parses a XML from a String into a XML DOM object.</p>
    */
    interface XmlParser {
        parse(data: string): Document;
    }
}
declare module io.retype.xml {
    /**
    * <p>Node XML parsing.</p>
    */
    class NodeXmlParser implements XmlParser {
        public parse(data: string): Document;
    }
}
declare module io.retype.xml {
    /**
    * <p>A parser for XML for the IE browsers.</p>
    */
    class IeXmlParser implements XmlParser {
        public parse(data: string): Document;
    }
}
declare module io.retype.xml {
    /**
    * <p>A normal W3C standard compliant browser parser.</p>
    */
    class BrowserXmlParser implements XmlParser {
        public parse(data: string): Document;
    }
}
declare module io.retype.xml {
    enum ParserType {
        DEFAULT = 0,
        NODE = 1,
        IE = 2,
    }
    class XmlParserFactory {
        static createParserInstance(): XmlParser;
    }
}
declare module io.retype.xml {
    class XmlFormat {
        public format(xmlDocument: XMLDocument): string;
    }
}
